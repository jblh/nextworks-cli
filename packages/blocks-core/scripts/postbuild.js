const fs = require("fs");
const path = require("path");

const distDir = path.join(__dirname, "..", "dist");
const distCjsDir = path.join(__dirname, "..", "dist-cjs");
const distTypesDir = path.join(__dirname, "..", "dist-types");

if (!fs.existsSync(distDir)) {
  console.error("dist directory not found for @nextworks/blocks-core");
  process.exit(1);
}

if (!fs.existsSync(distCjsDir)) {
  console.error(
    "dist-cjs directory not found for @nextworks/blocks-core. Did you run build:cjs?\n",
  );
  process.exit(1);
}

if (!fs.existsSync(distTypesDir)) {
  console.error(
    "dist-types directory not found for @nextworks/blocks-core. Did you run build:types?\n",
  );
  process.exit(1);
}

// Copy generated .d.ts files from dist-types into dist so runtime JS and types stay in sync
function copyDtsFiles(srcDir, destDir) {
  const entries = fs.readdirSync(srcDir, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(srcDir, entry.name);
    const destPath = path.join(destDir, entry.name);

    if (entry.isDirectory()) {
      if (!fs.existsSync(destPath)) {
        fs.mkdirSync(destPath, { recursive: true });
      }
      copyDtsFiles(srcPath, destPath);
    } else if (entry.isFile() && entry.name.endsWith(".d.ts")) {
      const contents = fs.readFileSync(srcPath, "utf8");
      fs.writeFileSync(destPath, contents, "utf8");
    }
  }
}

copyDtsFiles(distTypesDir, distDir);

// Rename dist-cjs/**/*.js -> dist-cjs/**/*.cjs so Node can `require()` even if
// the package ever becomes `type: module` or is treated as ESM by tooling.
function renameJsToCjs(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      renameJsToCjs(fullPath);
      continue;
    }

    if (entry.isFile() && entry.name.endsWith(".js")) {
      const nextPath = fullPath.replace(/\.js$/, ".cjs");
      fs.renameSync(fullPath, nextPath);
    }
  }
}

// After renaming files, rewrite relative require() targets so Node can resolve
// them with the new `.cjs` extension.
function rewriteCjsRequires(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      rewriteCjsRequires(fullPath);
      continue;
    }

    if (!entry.isFile() || !entry.name.endsWith(".cjs")) continue;

    let contents = fs.readFileSync(fullPath, "utf8");

    // Rewrite require('./x') and require("./x") to require('./x.cjs')
    // Also handles nested paths like ./lib/themes
    contents = contents.replace(
      /require\((['"])\.(\/[^'"]+)\1\)/g,
      "require($1.$2.cjs$1)",
    );

    fs.writeFileSync(fullPath, contents, "utf8");
  }
}

renameJsToCjs(distCjsDir);
rewriteCjsRequires(distCjsDir);

// Note: we intentionally do not generate `dist/index.d.ts` here.
// It is produced by TypeScript from src/index.ts (via build:types) and then copied
// into dist/ by copyDtsFiles(). This keeps runtime JS exports and types in sync
// without maintaining a hard-coded export list.

const serverDts = `
// Auto-generated by scripts/postbuild.js
// Keep this file in sync with src/server.ts runtime exports.
export { default as AppProviders } from "./components/AppProviders.server";
`;

fs.writeFileSync(path.join(distDir, "server.d.ts"), serverDts, "utf8");
